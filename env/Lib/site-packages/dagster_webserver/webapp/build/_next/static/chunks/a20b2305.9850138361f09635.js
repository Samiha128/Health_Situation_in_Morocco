"use strict";(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[401],{53476:function(e,t,n){let r;n.d(t,{Wh:function(){return iT},Zl:function(){return iA},cn:function(){return iR},sJ:function(){return iE}});var o,i,a,l,s=n(2784),u=n(28316),c=n(34406),d=function(e){let t=Error(e);if(void 0===t.stack)try{throw t}catch(e){}return t},f=function(e){return!!e&&"function"==typeof e.then},h=function(e,t){if(null!=e)return e;throw d(null!=t?t:"Got unexpected null or undefined")};function p(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}class v{getValue(){throw d("BaseLoadable")}toPromise(){throw d("BaseLoadable")}valueMaybe(){throw d("BaseLoadable")}valueOrThrow(){throw d(`Loadable expected value, but in "${this.state}" state`)}promiseMaybe(){throw d("BaseLoadable")}promiseOrThrow(){throw d(`Loadable expected promise, but in "${this.state}" state`)}errorMaybe(){throw d("BaseLoadable")}errorOrThrow(){throw d(`Loadable expected error, but in "${this.state}" state`)}is(e){return e.state===this.state&&e.contents===this.contents}map(e){throw d("BaseLoadable")}}class _ extends v{constructor(e){super(),p(this,"state","hasValue"),p(this,"contents",void 0),this.contents=e}getValue(){return this.contents}toPromise(){return Promise.resolve(this.contents)}valueMaybe(){return this.contents}valueOrThrow(){return this.contents}promiseMaybe(){}errorMaybe(){}map(e){try{let t=e(this.contents);return f(t)?b(t):R(t)?t:g(t)}catch(t){return f(t)?b(t.next(()=>this.map(e))):S(t)}}}class y extends v{constructor(e){super(),p(this,"state","hasError"),p(this,"contents",void 0),this.contents=e}getValue(){throw this.contents}toPromise(){return Promise.reject(this.contents)}valueMaybe(){}promiseMaybe(){}errorMaybe(){return this.contents}errorOrThrow(){return this.contents}map(e){return this}}class m extends v{constructor(e){super(),p(this,"state","loading"),p(this,"contents",void 0),this.contents=e}getValue(){throw this.contents}toPromise(){return this.contents}valueMaybe(){}promiseMaybe(){return this.contents}promiseOrThrow(){return this.contents}errorMaybe(){}map(e){return b(this.contents.then(t=>{let n=e(t);if(R(n))switch(n.state){case"hasValue":case"loading":return n.contents;case"hasError":throw n.contents}return n}).catch(t=>{if(f(t))return t.then(()=>this.map(e).contents);throw t}))}}function g(e){return Object.freeze(new _(e))}function S(e){return Object.freeze(new y(e))}function b(e){return Object.freeze(new m(e))}function w(){return Object.freeze(new m(new Promise(()=>{})))}function T(e){var t;let n=(t=(Array.isArray(e)?e:Object.getOwnPropertyNames(e).map(t=>e[t])).map(e=>R(e)?e:f(e)?b(e):g(e))).every(e=>"hasValue"===e.state)?g(t.map(e=>e.contents)):t.some(e=>"hasError"===e.state)?S(h(t.find(e=>"hasError"===e.state),"Invalid loadable passed to loadableAll").contents):b(Promise.all(t.map(e=>e.contents)));return Array.isArray(e)?n:n.map(t=>Object.getOwnPropertyNames(e).reduce((e,n,r)=>({...e,[n]:t[r]}),{}))}function R(e){return e instanceof v}var E=Object.freeze({__proto__:null,loadableWithValue:g,loadableWithError:S,loadableWithPromise:b,loadableLoading:w,loadableAll:T,isLoadable:R,RecoilLoadable:{of:e=>f(e)?b(e):R(e)?e:g(e),error:e=>S(e),loading:()=>w(),all:T,isLoadable:R}});let A={RECOIL_DUPLICATE_ATOM_KEY_CHECKING_ENABLED:!0,RECOIL_GKS_ENABLED:new Set(["recoil_hamt_2020","recoil_sync_external_store","recoil_suppress_rerender_in_callback","recoil_memory_managament_2020"])};function N(e){return A.RECOIL_GKS_ENABLED.has(e)}void 0!==c&&(null==c?void 0:c.env)!=null&&(function(e,t){var n,r;let o=null===(n=c.env[e])||void 0===n?void 0:null===(r=n.toLowerCase())||void 0===r?void 0:r.trim();if(null!=o&&""!==o){if(!["true","false"].includes(o))throw d(`process.env.${e} value must be 'true', 'false', or empty: ${o}`);t("true"===o)}}("RECOIL_DUPLICATE_ATOM_KEY_CHECKING_ENABLED",e=>{A.RECOIL_DUPLICATE_ATOM_KEY_CHECKING_ENABLED=e}),function(e,t){var n;let r=null===(n=c.env[e])||void 0===n?void 0:n.trim();null!=r&&""!==r&&t(r.split(/\s*,\s*|\s+/))}("RECOIL_GKS_ENABLED",e=>{e.forEach(e=>{A.RECOIL_GKS_ENABLED.add(e)})})),N.setPass=e=>{A.RECOIL_GKS_ENABLED.add(e)},N.setFail=e=>{A.RECOIL_GKS_ENABLED.delete(e)},N.clear=()=>{A.RECOIL_GKS_ENABLED.clear()};var k=function(e,t,{error:n}={}){return null};let L=null!==(i=s.createMutableSource)&&void 0!==i?i:s.unstable_createMutableSource,C=null!==(a=s.useMutableSource)&&void 0!==a?a:s.unstable_useMutableSource,V=null!==(l=s.useSyncExternalStore)&&void 0!==l?l:s.unstable_useSyncExternalStore,M=!1;var D={createMutableSource:L,useMutableSource:C,useSyncExternalStore:V,currentRendererSupportsUseSyncExternalStore:function(){var e;let{ReactCurrentDispatcher:t,ReactCurrentOwner:n}=s.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED,r=null!=(null!==(e=null==t?void 0:t.current)&&void 0!==e?e:n.currentDispatcher).useSyncExternalStore;return!V||r||M||(M=!0,k("A React renderer without React 18+ API support is being used with React 18+.")),r},reactMode:function(){return N("recoil_transition_support")?{mode:"TRANSITION_SUPPORT",early:!0,concurrent:!0}:N("recoil_sync_external_store")&&null!=V?{mode:"SYNC_EXTERNAL_STORE",early:!0,concurrent:!1}:N("recoil_mutable_source")&&null!=C&&"undefined"!=typeof window&&!window.$disableRecoilValueMutableSource_TEMP_HACK_DO_NOT_USE?N("recoil_suppress_rerender_in_callback")?{mode:"MUTABLE_SOURCE",early:!0,concurrent:!0}:{mode:"MUTABLE_SOURCE",early:!1,concurrent:!1}:N("recoil_suppress_rerender_in_callback")?{mode:"LEGACY",early:!0,concurrent:!1}:{mode:"LEGACY",early:!1,concurrent:!1}},isFastRefreshEnabled:function(){return!1}};class I{constructor(e){p(this,"key",void 0),this.key=e}toJSON(){return{key:this.key}}}class U extends I{}class O extends I{}var B=Object.freeze({__proto__:null,AbstractRecoilValue:I,RecoilState:U,RecoilValueReadOnly:O,isRecoilValue:function(e){return e instanceof U||e instanceof O}}),x=function(e,...t){},P=function(e,t){return function*(){let n=0;for(let r of e)yield t(r,n++)}()};let{isFastRefreshEnabled:z}=D;class F{}let $=new F,G=new Map,W=new Map;class K extends Error{}let j=new Map;function H(e){return j.get(e)}var q={nodes:G,recoilValues:W,registerNode:function(e){var t;A.RECOIL_DUPLICATE_ATOM_KEY_CHECKING_ENABLED&&(t=e.key,G.has(t)&&console.warn(`Duplicate atom key "${t}". This is a FATAL ERROR in
      production. But it is safe to ignore this warning if it occurred because of
      hot module replacement.`)),G.set(e.key,e);let n=null==e.set?new B.RecoilValueReadOnly(e.key):new B.RecoilState(e.key);return W.set(e.key,n),n},getNode:function(e){let t=G.get(e);if(null==t)throw new K(`Missing definition for RecoilValue: "${e}""`);return t},getNodeMaybe:function(e){return G.get(e)},deleteNodeConfigIfPossible:function(e){var t,n;if(!N("recoil_memory_managament_2020"))return;let r=G.get(e);null!=r&&null!==(t=r.shouldDeleteConfigOnRelease)&&void 0!==t&&t.call(r)&&(G.delete(e),null===(n=H(e))||void 0===n||n(),j.delete(e))},setConfigDeletionHandler:function(e,t){N("recoil_memory_managament_2020")&&(void 0===t?j.delete(e):j.set(e,t))},getConfigDeletionHandler:H,recoilValuesForKeys:function(e){return P(e,e=>h(W.get(e)))},NodeMissingError:K,DefaultValue:F,DEFAULT_VALUE:$},Z=function(e,t){t()},Y=(function(e){var t="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e},n={},r={},o=function(e){return function(){return e}},i=n.hash=function(e){var n=void 0===e?"undefined":t(e);if("number"===n)return e;"string"!==n&&(e+="");for(var r=0,o=0,i=e.length;o<i;++o)r=(r<<5)-r+e.charCodeAt(o)|0;return r},a=function(e,t){return t>>>e&31},l=function(e){return 1<<e},s=function(e,t){var n;return n=e&t-1,n-=n>>1&1431655765,n=(n=(858993459&n)+(n>>2&858993459))+(n>>4)&252645135,n+=n>>8,127&(n+=n>>16)},u=function(e,t,n,r){var o=r;if(!e){var i=r.length;o=Array(i);for(var a=0;a<i;++a)o[a]=r[a]}return o[t]=n,o},c=function(e,t,n){var r=n.length-1,o=0,i=0,a=n;if(e)o=i=t;else for(a=Array(r);o<t;)a[i++]=n[o++];for(++o;o<=r;)a[i++]=n[o++];return e&&(a.length=r),a},d=function(e,t,n,r){var o=r.length;if(e){for(var i=o;i>=t;)r[i--]=r[i];return r[t]=n,r}for(var a=0,l=0,s=Array(o+1);a<t;)s[l++]=r[a++];for(s[t]=n;a<o;)s[++l]=r[a++];return s},f={__hamt_isEmpty:!0},h=function(e){return e===f||e&&e.__hamt_isEmpty},p=function(e,t,n,r){return{type:1,edit:e,hash:t,key:n,value:r,_modify:T}},v=function(e,t,n){return{type:2,edit:e,hash:t,children:n,_modify:R}},_=function(e,t,n){return{type:3,edit:e,mask:t,children:n,_modify:E}},y=function(e,t,n){return{type:4,edit:e,size:t,children:n,_modify:A}},m=function(e,t,n,r,o){for(var i=[],a=r,l=0,s=0;a;++s)1&a&&(i[s]=o[l++]),a>>>=1;return i[t]=n,y(e,l+1,i)},g=function(e,t,n,r){for(var o=Array(t-1),i=0,a=0,l=0,s=r.length;l<s;++l)if(l!==n){var u=r[l];u&&!h(u)&&(o[i++]=u,a|=1<<l)}return _(e,a,o)},S=function e(t,n,r,o,i,s){if(r===i)return v(t,r,[s,o]);var u=a(n,r),c=a(n,i);return _(t,l(u)|l(c),u===c?[e(t,n+5,r,o,i,s)]:u<c?[o,s]:[s,o])},b=function(e,t,n,o,i,a,l,s){for(var d=i.length,f=0;f<d;++f){var h=i[f];if(n(l,h.key)){var v=h.value,_=a(v);if(_===v)return i;if(_===r)return--s.value,c(e,f,i);return u(e,f,p(t,o,l,_),i)}}var y=a();return y===r?i:(++s.value,u(e,d,p(t,o,l,y),i))},w=function(e,t){return e===t.edit},T=function(e,t,n,o,i,a,l){if(t(a,this.key)){var s=o(this.value);return s===this.value?this:s===r?(--l.value,f):w(e,this)?(this.value=s,this):p(e,i,a,s)}var u=o();return u===r?this:(++l.value,S(e,n,this.hash,this,i,p(e,i,a,u)))},R=function(e,t,n,o,i,a,l){if(i===this.hash){var s=b(w(e,this),e,t,this.hash,this.children,o,a,l);return s===this.children?this:s.length>1?v(e,this.hash,s):s[0]}var u=o();return u===r?this:(++l.value,S(e,n,this.hash,this,i,p(e,i,a,u)))},E=function(e,t,n,r,o,i,p){var v,y=this.mask,g=this.children,S=a(n,o),b=l(S),T=s(y,b),R=y&b,E=R?g[T]:f,A=E._modify(e,t,n+5,r,o,i,p);if(E===A)return this;var N=w(e,this),k=y,L=void 0;if(R&&h(A)){if(!(k&=~b))return f;if(g.length<=2&&((v=g[1^T])===f||1===v.type||2===v.type))return g[1^T];L=c(N,T,g)}else if(R||h(A))L=u(N,T,A,g);else{if(g.length>=16)return m(e,S,A,y,g);k|=b,L=d(N,T,A,g)}return N?(this.mask=k,this.children=L,this):_(e,k,L)},A=function(e,t,n,r,o,i,l){var s=this.size,c=this.children,d=a(n,o),p=c[d],v=(p||f)._modify(e,t,n+5,r,o,i,l);if(p===v)return this;var _=w(e,this),m=void 0;if(h(p)&&!h(v))++s,m=u(_,d,v,c);else if(!h(p)&&h(v)){if(--s<=8)return g(e,s,d,c);m=u(_,d,f,c)}else m=u(_,d,v,c);return _?(this.size=s,this.children=m,this):y(e,s,m)};function N(e,t,n,r,o){this._editable=e,this._edit=t,this._config=n,this._root=r,this._size=o}f._modify=function(e,t,n,o,i,a,l){var s=o();return s===r?f:(++l.value,p(e,i,a,s))},N.prototype.setTree=function(e,t){return this._editable?(this._root=e,this._size=t,this):e===this._root?this:new N(this._editable,this._edit,this._config,e,t)};var k=n.tryGetHash=function(e,t,n,r){for(var o=r._root,i=0,u=r._config.keyEq;;)switch(o.type){case 1:return u(n,o.key)?o.value:e;case 2:if(t===o.hash)for(var c=o.children,d=0,f=c.length;d<f;++d){var h=c[d];if(u(n,h.key))return h.value}return e;case 3:var p=l(a(i,t));if(o.mask&p){o=o.children[s(o.mask,p)],i+=5;break}return e;case 4:if(o=o.children[a(i,t)]){i+=5;break}return e;default:return e}};N.prototype.tryGetHash=function(e,t,n){return k(e,t,n,this)};var L=n.tryGet=function(e,t,n){return k(e,n._config.hash(t),t,n)};N.prototype.tryGet=function(e,t){return L(e,t,this)};var C=n.getHash=function(e,t,n){return k(void 0,e,t,n)};N.prototype.getHash=function(e,t){return C(e,t,this)},n.get=function(e,t){return k(void 0,t._config.hash(e),e,t)},N.prototype.get=function(e,t){return L(t,e,this)};var V=n.has=function(e,t,n){return k(r,e,t,n)!==r};N.prototype.hasHash=function(e,t){return V(e,t,this)};var M=n.has=function(e,t){return V(t._config.hash(e),e,t)};N.prototype.has=function(e){return M(e,this)};var D=function(e,t){return e===t};n.make=function(e){return new N(0,0,{keyEq:e&&e.keyEq||D,hash:e&&e.hash||i},f,0)},n.empty=n.make();var I=n.isEmpty=function(e){return e&&!!h(e._root)};N.prototype.isEmpty=function(){return I(this)};var U=n.modifyHash=function(e,t,n,r){var o={value:r._size},i=r._root._modify(r._editable?r._edit:NaN,r._config.keyEq,0,e,t,n,o);return r.setTree(i,o.value)};N.prototype.modifyHash=function(e,t,n){return U(n,e,t,this)};var O=n.modify=function(e,t,n){return U(e,n._config.hash(t),t,n)};N.prototype.modify=function(e,t){return O(t,e,this)};var B=n.setHash=function(e,t,n,r){return U(o(n),e,t,r)};N.prototype.setHash=function(e,t,n){return B(e,t,n,this)};var x=n.set=function(e,t,n){return B(n._config.hash(e),e,t,n)};N.prototype.set=function(e,t){return x(e,t,this)};var P=o(r),z=n.removeHash=function(e,t,n){return U(P,e,t,n)};N.prototype.removeHash=N.prototype.deleteHash=function(e,t){return z(e,t,this)};var F=n.remove=function(e,t){return z(t._config.hash(e),e,t)};N.prototype.remove=N.prototype.delete=function(e){return F(e,this)};var $=n.beginMutation=function(e){return new N(e._editable+1,e._edit+1,e._config,e._root,e._size)};N.prototype.beginMutation=function(){return $(this)};var G=n.endMutation=function(e){return e._editable=e._editable&&e._editable-1,e};N.prototype.endMutation=function(){return G(this)};var W=n.mutate=function(e,t){var n=$(t);return e(n),G(n)};N.prototype.mutate=function(e){return W(e,this)};var K=function(e){return e&&j(e[0],e[1],e[2],e[3],e[4])},j=function(e,t,n,r,o){for(;n<e;){var i=t[n++];if(i&&!h(i))return H(i,r,[e,t,n,r,o])}return K(o)},H=function(e,t,n){switch(e.type){case 1:return{value:t(e),rest:n};case 2:case 4:case 3:var r=e.children;return j(r.length,r,0,t,n);default:return K(n)}},q={done:!0};function Z(e){this.v=e}Z.prototype.next=function(){if(!this.v)return q;var e=this.v;return this.v=K(e.rest),e},Z.prototype[Symbol.iterator]=function(){return this};var Y=function(e,t){return new Z(H(e._root,t))},J=function(e){return[e.key,e.value]},X=n.entries=function(e){return Y(e,J)};N.prototype.entries=N.prototype[Symbol.iterator]=function(){return X(this)};var Q=function(e){return e.key},ee=n.keys=function(e){return Y(e,Q)};N.prototype.keys=function(){return ee(this)};var et=function(e){return e.value},en=n.values=N.prototype.values=function(e){return Y(e,et)};N.prototype.values=function(){return en(this)};var er=n.fold=function(e,t,n){var r=n._root;if(1===r.type)return e(t,r.value,r.key);for(var o=[r.children],i=void 0;i=o.pop();)for(var a=0,l=i.length;a<l;){var s=i[a++];s&&s.type&&(1===s.type?t=e(t,s.value,s.key):o.push(s.children))}return t};N.prototype.fold=function(e,t){return er(e,t,this)};var eo=n.forEach=function(e,t){return er(function(n,r,o){return e(r,o,t)},null,t)};N.prototype.forEach=function(e){return eo(e,this)};var ei=n.count=function(e){return e._size};N.prototype.count=function(){return ei(this)},Object.defineProperty(N.prototype,"size",{get:N.prototype.count}),e.exports?e.exports=n:undefined.hamt=n}(o={exports:{}},o.exports),o.exports);class J{constructor(e){p(this,"_map",void 0),this._map=new Map(null==e?void 0:e.entries())}keys(){return this._map.keys()}entries(){return this._map.entries()}get(e){return this._map.get(e)}has(e){return this._map.has(e)}set(e,t){return this._map.set(e,t),this}delete(e){return this._map.delete(e),this}clone(){return Q(this)}toMap(){return new Map(this._map)}}class X{constructor(e){if(p(this,"_hamt",Y.empty.beginMutation()),e instanceof X){let t=e._hamt.endMutation();e._hamt=t.beginMutation(),this._hamt=t.beginMutation()}else if(e)for(let[t,n]of e.entries())this._hamt.set(t,n)}keys(){return this._hamt.keys()}entries(){return this._hamt.entries()}get(e){return this._hamt.get(e)}has(e){return this._hamt.has(e)}set(e,t){return this._hamt.set(e,t),this}delete(e){return this._hamt.delete(e),this}clone(){return Q(this)}toMap(){return new Map(this._hamt)}}function Q(e){return N("recoil_hamt_2020")?new X(e):new J(e)}var ee=Object.freeze({__proto__:null,persistentMap:{persistentMap:Q}.persistentMap}),et=function(e,...t){let n=new Set;e:for(let r of e){for(let e of t)if(e.has(r))continue e;n.add(r)}return n},en=function(e,t){let n=new Map;return e.forEach((e,r)=>{n.set(r,t(e,r))}),n};function er(e,t,n,r){let{nodeDeps:o,nodeToNodeSubscriptions:i}=n,a=o.get(e);if(!a||!r||a===r.nodeDeps.get(e)){for(let n of(o.set(e,t),null==a?t:et(t,a)))i.has(n)||i.set(n,new Set),h(i.get(n)).add(e);if(a)for(let n of et(a,t)){if(!i.has(n))return;let t=h(i.get(n));t.delete(e),0===t.size&&i.delete(n)}}}var eo={cloneGraph:function(e){return{nodeDeps:en(e.nodeDeps,e=>new Set(e)),nodeToNodeSubscriptions:en(e.nodeToNodeSubscriptions,e=>new Set(e))}},graph:function(){return{nodeDeps:new Map,nodeToNodeSubscriptions:new Map}},saveDepsToStore:function(e,t,n,r){var o,i,a,l,s;let u=n.getState();r===u.currentTree.version||r===(null===(o=u.nextTree)||void 0===o?void 0:o.version)||r===(null===(i=u.previousTree)||void 0===i?void 0:i.version)||k("Tried to save dependencies to a discarded tree");let c=n.getGraph(r);if(er(e,t,c),r===(null===(a=u.previousTree)||void 0===a?void 0:a.version)&&er(e,t,n.getGraph(u.currentTree.version),c),r===(null===(l=u.previousTree)||void 0===l?void 0:l.version)||r===u.currentTree.version){let r=null===(s=u.nextTree)||void 0===s?void 0:s.version;void 0!==r&&er(e,t,n.getGraph(r),c)}}};let ei=0,ea=0,el=0;var es={getNextTreeStateVersion:()=>ei++,getNextStoreID:()=>ea++,getNextComponentID:()=>el++};let{persistentMap:eu}=ee,{graph:ec}=eo,{getNextTreeStateVersion:ed}=es;function ef(){let e=ed();return{version:e,stateID:e,transactionMetadata:{},dirtyAtoms:new Set,atomValues:eu(),nonvalidatedAtoms:eu()}}var eh={makeEmptyTreeState:ef,makeEmptyStoreState:function(){let e=ef();return{currentTree:e,nextTree:null,previousTree:null,commitDepth:0,knownAtoms:new Set,knownSelectors:new Set,transactionSubscriptions:new Map,nodeTransactionSubscriptions:new Map,nodeToComponentSubscriptions:new Map,queuedComponentCallbacks_DEPRECATED:[],suspendedComponentResolvers:new Set,graphsByVersion:new Map().set(e.version,ec()),retention:{referenceCounts:new Map,nodesRetainedByZone:new Map,retainablesToCheckForRelease:new Set},nodeCleanupFunctions:new Map}},getNextTreeStateVersion:ed};class ep{}var ev={RetentionZone:ep,retentionZone:function(){return new ep}},e_={setByAddingToSet:function(e,t){let n=new Set(e);return n.add(t),n},setByDeletingFromSet:function(e,t){let n=new Set(e);return n.delete(t),n},mapBySettingInMap:function(e,t,n){let r=new Map(e);return r.set(t,n),r},mapByUpdatingInMap:function(e,t,n){let r=new Map(e);return r.set(t,n(r.get(t))),r},mapByDeletingFromMap:function(e,t){let n=new Map(e);return n.delete(t),n},mapByDeletingMultipleFromMap:function(e,t){let n=new Map(e);return t.forEach(e=>n.delete(e)),n}},ey=function*(e,t){let n=0;for(let r of e)t(r,n++)&&(yield r)},em=function(e,t){return new Proxy(e,{get:(e,n)=>(!(n in e)&&n in t&&(e[n]=t[n]()),e[n]),ownKeys:e=>Object.keys(e)})};let{getNode:eg,getNodeMaybe:eS,recoilValuesForKeys:eb}=q,{RetentionZone:ew}=ev,{setByAddingToSet:eT}=e_,eR=Object.freeze(new Set);class eE extends Error{}function eA(e,t,n,r){let o=e.getState();if(o.nodeCleanupFunctions.has(n))return;let i=eg(n),a=function(e,t,n){if(!N("recoil_memory_managament_2020"))return()=>void 0;let{nodesRetainedByZone:r}=e.getState().retention;function o(e){let n=r.get(e);n||r.set(e,n=new Set),n.add(t)}if(n instanceof ew)o(n);else if(Array.isArray(n))for(let e of n)o(e);return()=>{if(!N("recoil_memory_managament_2020"))return;let{retention:r}=e.getState();function o(e){let n=r.nodesRetainedByZone.get(e);null==n||n.delete(t),n&&0===n.size&&r.nodesRetainedByZone.delete(e)}if(n instanceof ew)o(n);else if(Array.isArray(n))for(let e of n)o(e)}}(e,n,i.retainedBy),l=i.init(e,t,r);o.nodeCleanupFunctions.set(n,()=>{l(),a()})}function eN(e,t,n){return eg(n).peek(e,t)}function ek(e,t,n){let r=new Set,o=Array.from(n),i=e.getGraph(t.version);for(let e=o.pop();e;e=o.pop()){var a;for(let t of(r.add(e),null!==(a=i.nodeToNodeSubscriptions.get(e))&&void 0!==a?a:eR))r.has(t)||o.push(t)}return r}var eL={getNodeLoadable:function(e,t,n){return eA(e,t,n,"get"),eg(n).get(e,t)},peekNodeLoadable:eN,setNodeValue:function(e,t,n,r){let o=eg(n);if(null==o.set)throw new eE(`Attempt to set read-only RecoilValue: ${n}`);let i=o.set;return eA(e,t,n,"set"),i(e,t,r)},initializeNode:function(e,t,n){eA(e,e.getState().currentTree,t,n)},cleanUpNode:function(e,t){var n;let r=e.getState();null===(n=r.nodeCleanupFunctions.get(t))||void 0===n||n(),r.nodeCleanupFunctions.delete(t)},setUnvalidatedAtomValue_DEPRECATED:function(e,t,n){var r;let o=eS(t);return null==o||null===(r=o.invalidate)||void 0===r||r.call(o,e),{...e,atomValues:e.atomValues.clone().delete(t),nonvalidatedAtoms:e.nonvalidatedAtoms.clone().set(t,n),dirtyAtoms:eT(e.dirtyAtoms,t)}},peekNodeInfo:function(e,t,n){let r=e.getState(),o=e.getGraph(t.version),i=eg(n).nodeType;return em({type:i},{loadable:()=>eN(e,t,n),isActive:()=>r.knownAtoms.has(n)||r.knownSelectors.has(n),isSet:()=>"selector"!==i&&t.atomValues.has(n),isModified:()=>t.dirtyAtoms.has(n),deps:()=>{var e;return eb(null!==(e=o.nodeDeps.get(n))&&void 0!==e?e:[])},subscribers:()=>{var o,i;return{nodes:eb(ey(ek(e,t,new Set([n])),e=>e!==n)),components:P(null!==(o=null===(i=r.nodeToComponentSubscriptions.get(n))||void 0===i?void 0:i.values())&&void 0!==o?o:[],([e])=>({name:e}))}}})},getDownstreamNodes:ek};let eC=null;var eV={setInvalidateMemoizedSnapshot:function(e){eC=e},invalidateMemoizedSnapshot:function(){var e;null===(e=eC)||void 0===e||e()}};let{getDownstreamNodes:eM,getNodeLoadable:eD,setNodeValue:eI}=eL,{getNextComponentID:eU}=es,{getNode:eO,getNodeMaybe:eB}=q,{DefaultValue:ex}=q,{reactMode:eP}=D,{AbstractRecoilValue:ez,RecoilState:eF,RecoilValueReadOnly:e$,isRecoilValue:eG}=B,{invalidateMemoizedSnapshot:eW}=eV;function eK(e,t,n){"hasValue"===n.state&&n.contents instanceof ex?e.atomValues.delete(t):e.atomValues.set(t,n),e.dirtyAtoms.add(t),e.nonvalidatedAtoms.delete(t)}function ej(e,t){e.replaceState(n=>{let r=eZ(n);for(let n of t)!function(e,t,n){if("set"===n.type){let{recoilValue:r,valueOrUpdater:o}=n,i=function(e,t,{key:n},r){if("function"!=typeof r)return r;{let o=eD(e,t,n);if("loading"===o.state){let e=`Tried to set atom or selector "${n}" using an updater function while the current state is pending, this is not currently supported.`;throw k(e),d(e)}if("hasError"===o.state)throw o.contents;return r(o.contents)}}(e,t,r,o);for(let[n,o]of eI(e,t,r.key,i).entries())eK(t,n,o)}else if("setLoadable"===n.type){let{recoilValue:{key:e},loadable:r}=n;eK(t,e,r)}else if("markModified"===n.type){let{recoilValue:{key:e}}=n;t.dirtyAtoms.add(e)}else if("setUnvalidated"===n.type){var r;let{recoilValue:{key:e},unvalidatedValue:o}=n,i=eB(e);null==i||null===(r=i.invalidate)||void 0===r||r.call(i,t),t.atomValues.delete(e),t.nonvalidatedAtoms.set(e,o),t.dirtyAtoms.add(e)}else k(`Unknown action ${n.type}`)}(e,r,n);return eY(e,r),eW(),r})}function eH(e,t){if(eq.length){let n=eq[eq.length-1],r=n.get(e);r||n.set(e,r=[]),r.push(t)}else ej(e,[t])}let eq=[];function eZ(e){return{...e,atomValues:e.atomValues.clone(),nonvalidatedAtoms:e.nonvalidatedAtoms.clone(),dirtyAtoms:new Set(e.dirtyAtoms)}}function eY(e,t){for(let o of eM(e,t,t.dirtyAtoms)){var n,r;null===(n=eB(o))||void 0===n||null===(r=n.invalidate)||void 0===r||r.call(n,t)}}function eJ(e,t,n){eH(e,{type:"set",recoilValue:t,valueOrUpdater:n})}var eX={RecoilValueReadOnly:e$,AbstractRecoilValue:ez,RecoilState:eF,getRecoilValueAsLoadable:function(e,{key:t},n=e.getState().currentTree){var r,o;let i=e.getState();n.version===i.currentTree.version||n.version===(null===(r=i.nextTree)||void 0===r?void 0:r.version)||n.version===(null===(o=i.previousTree)||void 0===o?void 0:o.version)||k("Tried to read from a discarded tree");let a=eD(e,n,t);return"loading"===a.state&&a.contents.catch(()=>{}),a},setRecoilValue:eJ,setRecoilValueLoadable:function(e,t,n){if(n instanceof ex)return eJ(e,t,n);eH(e,{type:"setLoadable",recoilValue:t,loadable:n})},markRecoilValueModified:function(e,t){eH(e,{type:"markModified",recoilValue:t})},setUnvalidatedRecoilValue:function(e,t,n){eH(e,{type:"setUnvalidated",recoilValue:t,unvalidatedValue:n})},subscribeToRecoilValue:function(e,{key:t},n,r=null){let o=eU(),i=e.getState();i.nodeToComponentSubscriptions.has(t)||i.nodeToComponentSubscriptions.set(t,new Map),h(i.nodeToComponentSubscriptions.get(t)).set(o,[null!=r?r:"<not captured>",n]);let a=eP();if(a.early&&("LEGACY"===a.mode||"MUTABLE_SOURCE"===a.mode)){let r=e.getState().nextTree;r&&r.dirtyAtoms.has(t)&&n(r)}return{release:()=>{let n=e.getState(),r=n.nodeToComponentSubscriptions.get(t);if(void 0===r||!r.has(o)){k(`Subscription missing at release time for atom ${t}. This is a bug in Recoil.`);return}r.delete(o),0===r.size&&n.nodeToComponentSubscriptions.delete(t)}}},isRecoilValue:eG,applyAtomValueWrites:function(e,t){let n=e.clone();return t.forEach((e,t)=>{"hasValue"===e.state&&e.contents instanceof ex?n.delete(t):n.set(t,e)}),n},batchStart:function(){let e=new Map;return eq.push(e),()=>{for(let[t,n]of e)ej(t,n);eq.pop()!==e&&k("Incorrect order of batch popping")}},writeLoadableToTreeState:eK,invalidateDownstreams:eY,copyTreeState:eZ,refreshRecoilValue:function(e,t){var n;let{currentTree:r}=e.getState(),o=eO(t.key);null===(n=o.clearCache)||void 0===n||n.call(o,e,r)}},eQ=function(e,t,n){let r=e.entries(),o=r.next();for(;!o.done;){let i=o.value;if(t.call(n,i[1],i[0],e))return!0;o=r.next()}return!1};let{cleanUpNode:e0}=eL,{deleteNodeConfigIfPossible:e1,getNode:e2}=q,{RetentionZone:e5}=ev,e4=new Set;function e3(e,t){let n=e.getState(),r=n.currentTree;if(n.nextTree){k("releaseNodesNowOnCurrentTree should only be called at the end of a batch");return}let o=new Set;for(let e of t)if(e instanceof e5)for(let t of function(e,t){var n;return null!==(n=e.retention.nodesRetainedByZone.get(t))&&void 0!==n?n:e4}(n,e))o.add(t);else o.add(e);for(let t of function(e,t){let n=e.getState(),r=n.currentTree,o=e.getGraph(r.version),i=new Set,a=new Set;return function t(l){var s,u;let c=new Set;for(let t of function(e,t,n,r,o){let i=e.getGraph(t.version),a=[],l=new Set;for(;n.size>0;)(function e(t){if(r.has(t)||o.has(t)){n.delete(t);return}if(l.has(t))return;let s=i.nodeToNodeSubscriptions.get(t);if(s)for(let t of s)e(t);l.add(t),n.delete(t),a.push(t)})(h(n.values().next().value));return a}(e,r,l,i,a)){if("recoilRoot"===e2(t).retainedBy||(null!==(s=n.retention.referenceCounts.get(t))&&void 0!==s?s:0)>0||e8(t).some(e=>n.retention.referenceCounts.get(e))){a.add(t);continue}let e=o.nodeToNodeSubscriptions.get(t);if(e&&eQ(e,e=>a.has(e))){a.add(t);continue}i.add(t),c.add(t)}let d=new Set;for(let e of c)for(let t of null!==(u=o.nodeDeps.get(e))&&void 0!==u?u:e4)i.has(t)||d.add(t);d.size&&t(d)}(t),i}(e,o))!function(e,t,n){var r,o;if(!N("recoil_memory_managament_2020"))return;e0(e,n);let i=e.getState();for(let e of(i.knownAtoms.delete(n),i.knownSelectors.delete(n),i.nodeTransactionSubscriptions.delete(n),i.retention.referenceCounts.delete(n),e8(n)))null===(r=i.retention.nodesRetainedByZone.get(e))||void 0===r||r.delete(n);t.atomValues.delete(n),t.dirtyAtoms.delete(n),t.nonvalidatedAtoms.delete(n);let a=i.graphsByVersion.get(t.version);if(a){let e=a.nodeDeps.get(n);if(void 0!==e)for(let t of(a.nodeDeps.delete(n),e))null===(o=a.nodeToNodeSubscriptions.get(t))||void 0===o||o.delete(n);a.nodeToNodeSubscriptions.delete(n)}e1(n)}(e,r,t)}function e8(e){let t=e2(e).retainedBy;return void 0===t||"components"===t||"recoilRoot"===t?[]:t instanceof e5?[t]:t}function e6(e,t){N("recoil_memory_managament_2020")&&(e.getState().retention.referenceCounts.delete(t),function(e,t){let n=e.getState();n.nextTree?n.retention.retainablesToCheckForRelease.add(t):e3(e,new Set([t]))}(e,t))}var e9={SUSPENSE_TIMEOUT_MS:12e4,updateRetainCount:function(e,t,n){var r;if(!N("recoil_memory_managament_2020"))return;let o=e.getState().retention.referenceCounts,i=(null!==(r=o.get(t))&&void 0!==r?r:0)+n;0===i?e6(e,t):o.set(t,i)},updateRetainCountToZero:e6,releaseScheduledRetainablesNow:function(e){if(!N("recoil_memory_managament_2020"))return;let t=e.getState();e3(e,t.retention.retainablesToCheckForRelease),t.retention.retainablesToCheckForRelease.clear()},retainedByOptionWithDefault:function(e){return void 0===e?"recoilRoot":e}};let{unstable_batchedUpdates:e7}=u,{unstable_batchedUpdates:te}={unstable_batchedUpdates:e7},{batchStart:tt}=eX,{unstable_batchedUpdates:tn}={unstable_batchedUpdates:te},tr=tn||(e=>e());var to={getBatcher:()=>tr,setBatcher:e=>{tr=e},batchUpdates:e=>{tr(()=>{let t=()=>void 0;try{t=tt(),e()}finally{t()}})}},ti=function*(e){for(let t of e)for(let e of t)yield e};let ta="undefined"==typeof Window||"undefined"==typeof window;var tl={isSSR:ta,isReactNative:"undefined"!=typeof navigator&&"ReactNative"===navigator.product,isWindow:e=>!ta&&(e===window||e instanceof Window)};let{batchUpdates:ts}=to,{initializeNode:tu,peekNodeInfo:tc}=eL,{graph:td}=eo,{getNextStoreID:tf}=es,{DEFAULT_VALUE:th,recoilValues:tp,recoilValuesForKeys:tv}=q,{AbstractRecoilValue:t_,getRecoilValueAsLoadable:ty,setRecoilValue:tm,setUnvalidatedRecoilValue:tg}=eX,{updateRetainCount:tS}=e9,{setInvalidateMemoizedSnapshot:tb}=eV,{getNextTreeStateVersion:tw,makeEmptyStoreState:tT}=eh,{isSSR:tR}=tl,{memoizeOneWithArgsHashAndInvalidation:tE}={memoizeWithArgsHash:function(e,t){let n;return(...r)=>{n||(n={});let o=t(...r);return Object.hasOwnProperty.call(n,o)||(n[o]=e(...r)),n[o]}},memoizeOneWithArgsHash:function(e,t){let n,r;return(...o)=>{let i=t(...o);return n===i?r:(n=i,r=e(...o))}},memoizeOneWithArgsHashAndInvalidation:function(e,t){let n,r;return[(...o)=>{let i=t(...o);return n===i?r:(n=i,r=e(...o))},()=>{n=null}]}};class tA{constructor(e,t){for(let n of(p(this,"_store",void 0),p(this,"_refCount",1),p(this,"getLoadable",e=>(this.checkRefCount_INTERNAL(),ty(this._store,e))),p(this,"getPromise",e=>(this.checkRefCount_INTERNAL(),this.getLoadable(e).toPromise())),p(this,"getNodes_UNSTABLE",e=>{if(this.checkRefCount_INTERNAL(),(null==e?void 0:e.isModified)===!0)return(null==e?void 0:e.isInitialized)===!1?[]:tv(this._store.getState().currentTree.dirtyAtoms);let t=this._store.getState().knownAtoms,n=this._store.getState().knownSelectors;return(null==e?void 0:e.isInitialized)==null?tp.values():!0===e.isInitialized?tv(ti([t,n])):ey(tp.values(),({key:e})=>!t.has(e)&&!n.has(e))}),p(this,"getInfo_UNSTABLE",({key:e})=>(this.checkRefCount_INTERNAL(),tc(this._store,this._store.getState().currentTree,e))),p(this,"map",e=>{this.checkRefCount_INTERNAL();let t=new tC(this,ts);return e(t),t}),p(this,"asyncMap",async e=>{this.checkRefCount_INTERNAL();let t=new tC(this,ts);return t.retain(),await e(t),t.autoRelease_INTERNAL(),t}),this._store={storeID:tf(),parentStoreID:t,getState:()=>e,replaceState:t=>{e.currentTree=t(e.currentTree)},getGraph:t=>{let n=e.graphsByVersion;if(n.has(t))return h(n.get(t));let r=td();return n.set(t,r),r},subscribeToTransactions:()=>({release:()=>{}}),addTransactionMetadata:()=>{throw d("Cannot subscribe to Snapshots")}},this._store.getState().knownAtoms))tu(this._store,n,"get"),tS(this._store,n,1);this.autoRelease_INTERNAL()}retain(){this._refCount<=0&&k("Attempt to retain() Snapshot that was already released."),this._refCount++;let e=!1;return()=>{e||(e=!0,this._release())}}autoRelease_INTERNAL(){tR||window.setTimeout(()=>this._release(),10)}_release(){if(this._refCount--,0===this._refCount){if(this._store.getState().nodeCleanupFunctions.forEach(e=>e()),this._store.getState().nodeCleanupFunctions.clear(),!N("recoil_memory_managament_2020"))return}else this._refCount}isRetained(){return this._refCount>0}checkRefCount_INTERNAL(){N("recoil_memory_managament_2020")&&this._refCount}getStore_INTERNAL(){return this.checkRefCount_INTERNAL(),this._store}getID(){return this.checkRefCount_INTERNAL(),this._store.getState().currentTree.stateID}getStoreID(){return this.checkRefCount_INTERNAL(),this._store.storeID}}function tN(e,t,n=!1){let r=e.getState(),o=n?tw():t.version;return{currentTree:{version:n?o:t.version,stateID:n?o:t.stateID,transactionMetadata:{...t.transactionMetadata},dirtyAtoms:new Set(t.dirtyAtoms),atomValues:t.atomValues.clone(),nonvalidatedAtoms:t.nonvalidatedAtoms.clone()},commitDepth:0,nextTree:null,previousTree:null,knownAtoms:new Set(r.knownAtoms),knownSelectors:new Set(r.knownSelectors),transactionSubscriptions:new Map,nodeTransactionSubscriptions:new Map,nodeToComponentSubscriptions:new Map,queuedComponentCallbacks_DEPRECATED:[],suspendedComponentResolvers:new Set,graphsByVersion:new Map().set(o,e.getGraph(t.version)),retention:{referenceCounts:new Map,nodesRetainedByZone:new Map,retainablesToCheckForRelease:new Set},nodeCleanupFunctions:new Map(P(r.nodeCleanupFunctions.entries(),([e])=>[e,()=>{}]))}}let[tk,tL]=tE((e,t)=>{var n;let r=e.getState();return new tA(tN(e,"latest"===t?null!==(n=r.nextTree)&&void 0!==n?n:r.currentTree:h(r.previousTree)),e.storeID)},(e,t)=>{var n,r;return String(t)+String(e.storeID)+String(null===(n=e.getState().nextTree)||void 0===n?void 0:n.version)+String(e.getState().currentTree.version)+String(null===(r=e.getState().previousTree)||void 0===r?void 0:r.version)});tb(tL);class tC extends tA{constructor(e,t){super(tN(e.getStore_INTERNAL(),e.getStore_INTERNAL().getState().currentTree,!0),e.getStoreID()),p(this,"_batch",void 0),p(this,"set",(e,t)=>{this.checkRefCount_INTERNAL();let n=this.getStore_INTERNAL();this._batch(()=>{tS(n,e.key,1),tm(this.getStore_INTERNAL(),e,t)})}),p(this,"reset",e=>{this.checkRefCount_INTERNAL();let t=this.getStore_INTERNAL();this._batch(()=>{tS(t,e.key,1),tm(this.getStore_INTERNAL(),e,th)})}),p(this,"setUnvalidatedAtomValues_DEPRECATED",e=>{this.checkRefCount_INTERNAL();let t=this.getStore_INTERNAL();ts(()=>{for(let[n,r]of e.entries())tS(t,n,1),tg(t,new t_(n),r)})}),this._batch=t}}var tV=Object.freeze({__proto__:null,Snapshot:tA,MutableSnapshot:tC,freshSnapshot:function(e){let t=new tA(tT());return null!=e?t.map(e):t},cloneSnapshot:function(e,t="latest"){let n=tk(e,t);return n.isRetained()?n:(tL(),tk(e,t))}}),tM=function(...e){let t=new Set;for(let n of e)for(let e of n)t.add(e);return t};let{useRef:tD}=s;var tI=function(e){let t=tD(e);return t.current===e&&"function"==typeof e&&(t.current=e()),t};let{getNextTreeStateVersion:tU,makeEmptyStoreState:tO}=eh,{cleanUpNode:tB,getDownstreamNodes:tx,initializeNode:tP,setNodeValue:tz,setUnvalidatedAtomValue_DEPRECATED:tF}=eL,{graph:t$}=eo,{cloneGraph:tG}=eo,{getNextStoreID:tW}=es,{createMutableSource:tK,reactMode:tj}=D,{applyAtomValueWrites:tH}=eX,{releaseScheduledRetainablesNow:tq}=e9,{freshSnapshot:tZ}=tV,{useCallback:tY,useContext:tJ,useEffect:tX,useMemo:tQ,useRef:t0,useState:t1}=s;function t2(){throw d("This component must be used inside a <RecoilRoot> component.")}let t5=Object.freeze({storeID:tW(),getState:t2,replaceState:t2,getGraph:t2,subscribeToTransactions:t2,addTransactionMetadata:t2}),t4=!1;function t3(e){if(t4)throw d("An atom update was triggered within the execution of a state updater function. State updater functions provided to Recoil must be pure functions.");let t=e.getState();if(null===t.nextTree){N("recoil_memory_managament_2020")&&N("recoil_release_on_cascading_update_killswitch_2021")&&t.commitDepth>0&&tq(e);let n=t.currentTree.version,r=tU();t.nextTree={...t.currentTree,version:r,stateID:r,dirtyAtoms:new Set,transactionMetadata:{}},t.graphsByVersion.set(r,tG(h(t.graphsByVersion.get(n))))}}let t8=s.createContext({current:t5}),t6=()=>tJ(t8),t9=s.createContext(null);function t7(e,t,n){for(let r of tx(e,n,n.dirtyAtoms)){let e=t.nodeToComponentSubscriptions.get(r);if(e)for(let[t,[r,o]]of e)o(n)}}function ne(e){let t=e.getState(),n=t.currentTree,r=n.dirtyAtoms;if(r.size){for(let[n,o]of t.nodeTransactionSubscriptions)if(r.has(n))for(let[t,n]of o)n(e);for(let[n,r]of t.transactionSubscriptions)r(e);(!tj().early||t.suspendedComponentResolvers.size>0)&&(t7(e,t,n),t.suspendedComponentResolvers.forEach(e=>e()),t.suspendedComponentResolvers.clear())}t.queuedComponentCallbacks_DEPRECATED.forEach(e=>e(n)),t.queuedComponentCallbacks_DEPRECATED.splice(0,t.queuedComponentCallbacks_DEPRECATED.length)}function nt({setNotifyBatcherOfChange:e}){let t=t6(),[,n]=t1([]);return e(()=>n({})),tX(()=>(e(()=>n({})),()=>{e(()=>{})}),[e]),tX(()=>{Z("Batcher",()=>{!function(e){let t=e.getState();t.commitDepth++;try{let{nextTree:n}=t;if(null==n)return;t.previousTree=t.currentTree,t.currentTree=n,t.nextTree=null,ne(e),null!=t.previousTree?t.graphsByVersion.delete(t.previousTree.version):k("Ended batch with no previous state, which is unexpected","recoil"),t.previousTree=null,N("recoil_memory_managament_2020")&&null==n&&tq(e)}finally{t.commitDepth--}}(t.current)})}),null}let nn=0;function nr({initializeState_DEPRECATED:e,initializeState:t,store_INTERNAL:n,children:r}){let o;let i=e=>{let t=o.current.graphsByVersion;if(t.has(e))return h(t.get(e));let n=t$();return t.set(e,n),n},a=(e,t)=>{if(null==t){let{transactionSubscriptions:t}=f.current.getState(),n=nn++;return t.set(n,e),{release:()=>{t.delete(n)}}}{let{nodeTransactionSubscriptions:n}=f.current.getState();n.has(t)||n.set(t,new Map);let r=nn++;return h(n.get(t)).set(r,e),{release:()=>{let e=n.get(t);e&&(e.delete(r),0===e.size&&n.delete(t))}}}},l=e=>{for(let t of(t3(f.current),Object.keys(e)))h(f.current.getState().nextTree).transactionMetadata[t]=e[t]},u=e=>{let t;t3(f.current);let n=h(o.current.nextTree);try{t4=!0,t=e(n)}finally{t4=!1}t!==n&&(o.current.nextTree=t,tj().early&&t7(f.current,o.current,t),h(c.current)())},c=t0(null),d=tY(e=>{c.current=e},[c]),f=tI(()=>null!=n?n:{storeID:tW(),getState:()=>o.current,replaceState:u,getGraph:i,subscribeToTransactions:a,addTransactionMetadata:l});null!=n&&(f.current=n);let p=tQ(()=>null==tK?void 0:tK(o,()=>o.current.currentTree.version),[o=tI(()=>null!=e?function(e,t){let n=tO();return t({set:(t,r)=>{let o=n.currentTree,i=tz(e,o,t.key,r),a=new Set(i.keys()),l=o.nonvalidatedAtoms.clone();for(let e of a)l.delete(e);n.currentTree={...o,dirtyAtoms:tM(o.dirtyAtoms,a),atomValues:tH(o.atomValues,i),nonvalidatedAtoms:l}},setUnvalidatedAtomValues:e=>{e.forEach((e,t)=>{n.currentTree=tF(n.currentTree,t,e)})}}),n}(f.current,e):null!=t?function(e){let t=tZ(e),n=t.getStore_INTERNAL().getState();return t.retain(),n.nodeCleanupFunctions.forEach(e=>e()),n.nodeCleanupFunctions.clear(),n}(t):tO())]);return tX(()=>{let e=f.current;for(let t of new Set(e.getState().knownAtoms))tP(e,t,"get");return()=>{for(let t of e.getState().knownAtoms)tB(e,t)}},[f]),s.createElement(t8.Provider,{value:f},s.createElement(t9.Provider,{value:p},s.createElement(nt,{setNotifyBatcherOfChange:d}),r))}var no={RecoilRoot:function(e){let{override:t,...n}=e,r=t6();return!1===t&&r.current!==t5?e.children:s.createElement(nr,n)},useStoreRef:t6,useRecoilMutableSource:function(){let e=tJ(t9);return null==e&&x("Attempted to use a Recoil hook outside of a <RecoilRoot>. <RecoilRoot> must be an ancestor of any component that uses Recoil hooks."),e},useRecoilStoreID:function(){return t6().current.storeID},notifyComponents_FOR_TESTING:t7,sendEndOfBatchNotifications_FOR_TESTING:ne},ni=function(e,t){if(e===t)return!0;if(e.length!==t.length)return!1;for(let n=0,r=e.length;n<r;n++)if(e[n]!==t[n])return!1;return!0};let{useEffect:na,useRef:nl}=s;var ns=function(e){let t=nl();return na(()=>{t.current=e}),t.current};let{useStoreRef:nu}=no,{SUSPENSE_TIMEOUT_MS:nc}=e9,{updateRetainCount:nd}=e9,{RetentionZone:nf}=ev,{useEffect:nh,useRef:np}=s,{isSSR:nv}=tl;var n_=function(e){if(N("recoil_memory_managament_2020"))return function(e){let t=(Array.isArray(e)?e:[e]).map(e=>e instanceof nf?e:e.key),n=nu();nh(()=>{if(!N("recoil_memory_managament_2020"))return;let e=n.current;if(r.current&&!nv)window.clearTimeout(r.current),r.current=null;else for(let n of t)nd(e,n,1);return()=>{for(let n of t)nd(e,n,-1)}},[n,...t]);let r=np(),o=ns(t);if(!nv&&(void 0===o||!ni(o,t))){let e=n.current;for(let n of t)nd(e,n,1);if(o)for(let t of o)nd(e,t,-1);r.current&&window.clearTimeout(r.current),r.current=window.setTimeout(()=>{for(let n of(r.current=null,t))nd(e,n,-1)},nc)}}(e)},ny=function(){return"<component name not available>"};let{batchUpdates:nm}=to,{DEFAULT_VALUE:ng}=q,{currentRendererSupportsUseSyncExternalStore:nS,reactMode:nb,useMutableSource:nw,useSyncExternalStore:nT}=D,{useRecoilMutableSource:nR,useStoreRef:nE}=no,{isRecoilValue:nA}=B,{AbstractRecoilValue:nN,getRecoilValueAsLoadable:nk,setRecoilValue:nL,setUnvalidatedRecoilValue:nC,subscribeToRecoilValue:nV}=eX,{useCallback:nM,useEffect:nD,useMemo:nI,useRef:nU,useState:nO}=s,{setByAddingToSet:nB}=e_,{isSSR:nx}=tl;function nP(e,t,n){if("hasValue"===e.state)return e.contents;if("loading"===e.state)throw new Promise(t=>{let r=n.current.getState().suspendedComponentResolvers;r.add(t),nx&&f(e.contents)&&e.contents.finally(()=>{r.delete(t)})});if("hasError"===e.state)throw e.contents;throw d(`Invalid value of loadable atom "${t.key}"`)}function nz(e){let t=nE(),n=ny(),r=nM(()=>{var n;let r=t.current,o=r.getState();return{loadable:nk(r,e,nb().early&&null!==(n=o.nextTree)&&void 0!==n?n:o.currentTree),key:e.key}},[t,e]),o=nM(e=>{let t;return()=>{var n,r;let o=e();return null!==(n=t)&&void 0!==n&&n.loadable.is(o.loadable)&&(null===(r=t)||void 0===r?void 0:r.key)===o.key?t:(t=o,o)}},[]),i=nI(()=>o(r),[r,o]);return nT(nM(r=>nV(t.current,e,r,n).release,[t,e,n]),i,i).loadable}function nF(e){let t=nE(),n=nM(()=>{var n;let r=t.current,o=r.getState();return nk(r,e,nb().early&&null!==(n=o.nextTree)&&void 0!==n?n:o.currentTree)},[t,e]),r=nM(()=>n(),[n]),o=ny(),i=nM((r,i)=>nV(t.current,e,()=>{if(!N("recoil_suppress_rerender_in_callback"))return i();let e=n();s.current.is(e)||i(),s.current=e},o).release,[t,e,o,n]),a=nR();if(null==a)throw d("Recoil hooks must be used in components contained within a <RecoilRoot> component.");let l=nw(a,r,i),s=nU(l);return nD(()=>{s.current=l}),l}function n$(e){let t=nE(),n=ny(),r=nM(()=>{var n;let r=t.current,o=r.getState();return nk(r,e,nb().early&&null!==(n=o.nextTree)&&void 0!==n?n:o.currentTree)},[t,e]),o=nM(()=>({loadable:r(),key:e.key}),[r,e.key]),i=nM(e=>{let t=o();return e.loadable.is(t.loadable)&&e.key===t.key?e:t},[o]);nD(()=>{let r=nV(t.current,e,e=>{l(i)},n);return l(i),r.release},[n,e,t,i]);let[a,l]=nO(o);return a.key!==e.key?o().loadable:a.loadable}function nG(e){let t=nE(),[,n]=nO([]),r=ny(),o=nM(()=>{var n;let r=t.current,o=r.getState();return nk(r,e,nb().early&&null!==(n=o.nextTree)&&void 0!==n?n:o.currentTree)},[t,e]),i=o(),a=nU(i);return nD(()=>{a.current=i}),nD(()=>{let i=t.current,l=i.getState(),s=nV(i,e,e=>{var t;if(!N("recoil_suppress_rerender_in_callback"))return n([]);let r=o();null!==(t=a.current)&&void 0!==t&&t.is(r)||n(r),a.current=r},r);if(l.nextTree)i.getState().queuedComponentCallbacks_DEPRECATED.push(()=>{a.current=null,n([])});else{var u;if(!N("recoil_suppress_rerender_in_callback"))return n([]);let e=o();null!==(u=a.current)&&void 0!==u&&u.is(e)||n(e),a.current=e}return s.release},[r,o,e,t]),i}function nW(e){return N("recoil_memory_managament_2020")&&n_(e),({TRANSITION_SUPPORT:n$,SYNC_EXTERNAL_STORE:nS()?nz:n$,MUTABLE_SOURCE:nF,LEGACY:nG})[nb().mode](e)}function nK(e){let t=nE();return nP(nW(e),e,t)}function nj(e){let t=nE();return nM(n=>{nL(t.current,e,n)},[t,e])}function nH(e){return N("recoil_memory_managament_2020")&&n_(e),n$(e)}function nq(e){let t=nE();return nP(nH(e),e,t)}var nZ=function(e,t){let n=new Map;for(let[r,o]of e)t(o,r)&&n.set(r,o);return n},nY=function(e,t){let n=new Set;for(let r of e)t(r)&&n.add(r);return n},nJ=function(...e){let t=new Map;for(let n=0;n<e.length;n++){let r;let o=e[n].keys();for(;!(r=o.next()).done;)t.set(r.value,e[n].get(r.value))}return t};let{batchUpdates:nX}=to,{DEFAULT_VALUE:nQ,getNode:n0,nodes:n1}=q,{useStoreRef:n2}=no,{AbstractRecoilValue:n5,setRecoilValueLoadable:n4}=eX,{SUSPENSE_TIMEOUT_MS:n3}=e9,{cloneSnapshot:n8}=tV,{useCallback:n6,useEffect:n9,useRef:n7,useState:re}=s,{isSSR:rt}=tl;function rn(e){let t=n2();n9(()=>t.current.subscribeToTransactions(e).release,[e,t])}function rr(e){let t=en(nZ(e.atomValues.toMap(),(e,t)=>{let n=n0(t).persistence_UNSTABLE;return null!=n&&"none"!==n.type&&"hasValue"===e.state}),e=>e.contents);return nJ(e.nonvalidatedAtoms.toMap(),t)}function ro(e,t){var n;let r=e.getState(),o=null!==(n=r.nextTree)&&void 0!==n?n:r.currentTree,i=t.getStore_INTERNAL().getState().currentTree;nX(()=>{let n=new Set;for(let e of[o.atomValues.keys(),i.atomValues.keys()])for(let t of e){var r,a;(null===(r=o.atomValues.get(t))||void 0===r?void 0:r.contents)!==(null===(a=i.atomValues.get(t))||void 0===a?void 0:a.contents)&&n0(t).shouldRestoreFromSnapshots&&n.add(t)}n.forEach(t=>{n4(e,new n5(t),i.atomValues.has(t)?h(i.atomValues.get(t)):nQ)}),e.replaceState(e=>({...e,stateID:t.getID()}))})}var ri={useRecoilSnapshot:function(){let e=n2(),[t,n]=re(()=>n8(e.current)),r=ns(t),o=n7(),i=n7();if(rn(n6(e=>n(n8(e)),[])),n9(()=>{let e=t.retain();if(o.current&&!rt){var n;window.clearTimeout(o.current),o.current=null,null===(n=i.current)||void 0===n||n.call(i),i.current=null}return()=>{window.setTimeout(e,10)}},[t]),r!==t&&!rt){if(o.current){var a;window.clearTimeout(o.current),o.current=null,null===(a=i.current)||void 0===a||a.call(i),i.current=null}i.current=t.retain(),o.current=window.setTimeout(()=>{var e;o.current=null,null===(e=i.current)||void 0===e||e.call(i),i.current=null},n3)}return t},gotoSnapshot:ro,useGotoRecoilSnapshot:function(){let e=n2();return n6(t=>ro(e.current,t),[e])},useRecoilTransactionObserver:function(e){rn(n6(t=>{e({snapshot:n8(t,"latest"),previousSnapshot:n8(t,"previous")})},[e]))},useTransactionObservation_DEPRECATED:function(e){rn(n6(t=>{let n=t.getState().previousTree,r=t.getState().currentTree;n||(k("Transaction subscribers notified without a previous tree being present -- this is a bug in Recoil"),n=t.getState().currentTree);let o=rr(r),i=rr(n),a=en(n1,e=>{var t,n,r,o;return{persistence_UNSTABLE:{type:null!==(t=null===(n=e.persistence_UNSTABLE)||void 0===n?void 0:n.type)&&void 0!==t?t:"none",backButton:null!==(r=null===(o=e.persistence_UNSTABLE)||void 0===o?void 0:o.backButton)&&void 0!==r&&r}}}),l=nY(r.dirtyAtoms,e=>o.has(e)||i.has(e));e({atomValues:o,previousAtomValues:i,atomInfo:a,modifiedAtoms:l,transactionMetadata:{...r.transactionMetadata}})},[e]))},useTransactionSubscription_DEPRECATED:rn};let{peekNodeInfo:ra}=eL,{useStoreRef:rl}=no,{reactMode:rs}=D,{RecoilRoot:ru,useStoreRef:rc}=no,{useMemo:rd}=s,{loadableWithValue:rf}=E,{initializeNode:rh}=eL,{DEFAULT_VALUE:rp,getNode:rv}=q,{copyTreeState:r_,getRecoilValueAsLoadable:ry,invalidateDownstreams:rm,writeLoadableToTreeState:rg}=eX;function rS(e){return"atom"===rv(e.key).nodeType}class rb{constructor(e,t){p(this,"_store",void 0),p(this,"_treeState",void 0),p(this,"_changes",void 0),p(this,"get",e=>{if(this._changes.has(e.key))return this._changes.get(e.key);if(!rS(e))throw d("Reading selectors within atomicUpdate is not supported");let t=ry(this._store,e,this._treeState);if("hasValue"===t.state)return t.contents;if("hasError"===t.state)throw t.contents;throw d(`Expected Recoil atom ${e.key} to have a value, but it is in a loading state.`)}),p(this,"set",(e,t)=>{if(!rS(e))throw d("Setting selectors within atomicUpdate is not supported");if("function"==typeof t){let n=this.get(e);this._changes.set(e.key,t(n))}else rh(this._store,e.key,"set"),this._changes.set(e.key,t)}),p(this,"reset",e=>{this.set(e,rp)}),this._store=e,this._treeState=t,this._changes=new Map}newTreeState_INTERNAL(){if(0===this._changes.size)return this._treeState;let e=r_(this._treeState);for(let[t,n]of this._changes)rg(e,t,rf(n));return rm(this._store,e),e}}var rw=Object.freeze({__proto__:null,atomicUpdater:function(e){return t=>{e.replaceState(n=>{let r=new rb(e,n);return t(r),r.newTreeState_INTERNAL()})}}}),rT=function(e,t){if(!e)throw Error(t)};let{atomicUpdater:rR}=rw,{batchUpdates:rE}=to,{DEFAULT_VALUE:rA}=q,{useStoreRef:rN}=no,{refreshRecoilValue:rk,setRecoilValue:rL}=eX,{cloneSnapshot:rC}=tV,{gotoSnapshot:rV}=ri,{useCallback:rM}=s;class rD{}let rI=new rD;function rU(e,t,n,r){let o,i=rI;if(rE(()=>{let a="useRecoilCallback() expects a function that returns a function: it accepts a function of the type (RecoilInterface) => (Args) => ReturnType and returns a callback function (Args) => ReturnType, where RecoilInterface is an object {snapshot, set, ...} and Args and ReturnType are the argument and return types of the callback you want to create.  Please see the docs at recoiljs.org for details.";if("function"!=typeof t)throw d(a);let l=t(em({...null!=r?r:{},set:(t,n)=>rL(e,t,n),reset:t=>rL(e,t,rA),refresh:t=>rk(e,t),gotoSnapshot:t=>rV(e,t),transact_UNSTABLE:t=>rR(e)(t)},{snapshot:()=>{let t=rC(e);return o=t.retain(),t}}));if("function"!=typeof l)throw d(a);i=l(...n)}),i instanceof rD&&rT(!1),f(i))i=i.finally(()=>{var e;null===(e=o)||void 0===e||e()});else{var a;null===(a=o)||void 0===a||a()}return i}var rO={recoilCallback:rU,useRecoilCallback:function(e,t){let n=rN();return rM((...t)=>rU(n.current,e,t),null!=t?[...t,n]:void 0)}};let{useStoreRef:rB}=no,{refreshRecoilValue:rx}=eX,{useCallback:rP}=s,{atomicUpdater:rz}=rw,{useStoreRef:rF}=no,{useMemo:r$}=s;class rG{constructor(e){p(this,"value",void 0),this.value=e}}var rW=Object.freeze({__proto__:null,WrappedValue:{WrappedValue:rG}.WrappedValue});let{isFastRefreshEnabled:rK}=D;class rj extends Error{}class rH{constructor(e){var t,n,r;p(this,"_name",void 0),p(this,"_numLeafs",void 0),p(this,"_root",void 0),p(this,"_onHit",void 0),p(this,"_onSet",void 0),p(this,"_mapNodeValue",void 0),this._name=null==e?void 0:e.name,this._numLeafs=0,this._root=null,this._onHit=null!==(t=null==e?void 0:e.onHit)&&void 0!==t?t:()=>{},this._onSet=null!==(n=null==e?void 0:e.onSet)&&void 0!==n?n:()=>{},this._mapNodeValue=null!==(r=null==e?void 0:e.mapNodeValue)&&void 0!==r?r:e=>e}size(){return this._numLeafs}root(){return this._root}get(e,t){var n;return null===(n=this.getLeafNode(e,t))||void 0===n?void 0:n.value}getLeafNode(e,t){if(null==this._root)return;let n=this._root;for(;n;){if(null==t||t.onNodeVisit(n),"leaf"===n.type)return this._onHit(n),n;let r=this._mapNodeValue(e(n.nodeKey));n=n.branches.get(r)}}set(e,t,n){let r=()=>{var r,o,i,a,l,s,u;let c,d;for(let[t,r]of e){let e=this._root;if((null==e?void 0:e.type)==="leaf")throw this.invalidCacheError();let o=c;if("branch"!==(c=null!==(l=c=o?o.branches.get(d):e)&&void 0!==l?l:{type:"branch",nodeKey:t,parent:o,branches:new Map,branchKey:d}).type||c.nodeKey!==t)throw this.invalidCacheError();null==o||o.branches.set(d,c),null==n||null===(s=n.onNodeVisit)||void 0===s||s.call(n,c),d=this._mapNodeValue(r),this._root=null!==(u=this._root)&&void 0!==u?u:c}let f=c?null===(r=c)||void 0===r?void 0:r.branches.get(d):this._root;if(null!=f&&("leaf"!==f.type||f.branchKey!==d))throw this.invalidCacheError();let h={type:"leaf",value:t,parent:c,branchKey:d};null===(o=c)||void 0===o||o.branches.set(d,h),this._root=null!==(i=this._root)&&void 0!==i?i:h,this._numLeafs++,this._onSet(h),null==n||null===(a=n.onNodeVisit)||void 0===a||a.call(n,h)};try{r()}catch(e){if(e instanceof rj)this.clear(),r();else throw e}}delete(e){let t=this.root();if(!t)return!1;if(e===t)return this._root=null,this._numLeafs=0,!0;let n=e.parent,r=e.branchKey;for(;n;){var o;if(n.branches.delete(r),n===t)return 0===n.branches.size?(this._root=null,this._numLeafs=0):this._numLeafs--,!0;if(n.branches.size>0)break;r=null===(o=n)||void 0===o?void 0:o.branchKey,n=n.parent}for(;n!==t;n=n.parent)if(null==n)return!1;return this._numLeafs--,!0}clear(){this._numLeafs=0,this._root=null}invalidCacheError(){throw k((rK()?"Possible Fast Refresh module reload detected.  This may also be caused by an selector returning inconsistent values. Resetting cache.":"Invalid cache values.  This happens when selectors do not return consistent values for the same input dependency values.  That may also be caused when using Fast Refresh to change a selector implementation.  Resetting cache.")+(null!=this._name?` - ${this._name}`:"")),new rj}}var rq=Object.freeze({__proto__:null,TreeCache:{TreeCache:rH}.TreeCache});class rZ{constructor(e){var t;p(this,"_maxSize",void 0),p(this,"_size",void 0),p(this,"_head",void 0),p(this,"_tail",void 0),p(this,"_map",void 0),p(this,"_keyMapper",void 0),this._maxSize=e.maxSize,this._size=0,this._head=null,this._tail=null,this._map=new Map,this._keyMapper=null!==(t=e.mapKey)&&void 0!==t?t:e=>e}head(){return this._head}tail(){return this._tail}size(){return this._size}maxSize(){return this._maxSize}has(e){return this._map.has(this._keyMapper(e))}get(e){let t=this._keyMapper(e),n=this._map.get(t);if(n)return this.set(e,n.value),n.value}set(e,t){let n=this._keyMapper(e);this._map.get(n)&&this.delete(e);let r=this.head(),o={key:e,right:r,left:null,value:t};r?r.left=o:this._tail=o,this._map.set(n,o),this._head=o,this._size++,this._maybeDeleteLRU()}_maybeDeleteLRU(){this.size()>this.maxSize()&&this.deleteLru()}deleteLru(){let e=this.tail();e&&this.delete(e.key)}delete(e){let t=this._keyMapper(e);if(!this._size||!this._map.has(t))return;let n=h(this._map.get(t)),r=n.right,o=n.left;r&&(r.left=n.left),o&&(o.right=n.right),n===this.head()&&(this._head=r),n===this.tail()&&(this._tail=o),this._map.delete(t),this._size--}clear(){this._size=0,this._head=null,this._tail=null,this._map=new Map}}var rY=Object.freeze({__proto__:null,LRUCache:{LRUCache:rZ}.LRUCache});let{LRUCache:rJ}=rY,{TreeCache:rX}=rq;var rQ=function({name:e,maxSize:t,mapNodeValue:n=e=>e}){let r=new rJ({maxSize:t}),o=new rX({name:e,mapNodeValue:n,onHit:e=>{r.set(e,!0)},onSet:e=>{let n=r.tail();r.set(e,!0),n&&o.size()>t&&o.delete(n.key)}});return o},r0=function(e,t={allowFunctions:!1}){return function e(t,n,r){if("string"==typeof t&&!t.includes('"')&&!t.includes("\\"))return`"${t}"`;switch(typeof t){case"undefined":return"";case"boolean":return t?"true":"false";case"number":case"symbol":return String(t);case"string":return JSON.stringify(t);case"function":if((null==n?void 0:n.allowFunctions)!==!0)throw d("Attempt to serialize function in a Recoil cache key");return`__FUNCTION(${t.name})__`}if(null===t)return"null";if("object"!=typeof t){var o;return null!==(o=JSON.stringify(t))&&void 0!==o?o:""}if(f(t))return"__PROMISE__";if(Array.isArray(t))return`[${t.map((t,r)=>e(t,n,r.toString()))}]`;if("function"==typeof t.toJSON)return e(t.toJSON(r),n,r);if(t instanceof Map){let o={};for(let[r,i]of t)o["string"==typeof r?r:e(r,n)]=i;return e(o,n,r)}return t instanceof Set?e(Array.from(t).sort((t,r)=>e(t,n).localeCompare(e(r,n))),n,r):void 0!==Symbol&&null!=t[Symbol.iterator]&&"function"==typeof t[Symbol.iterator]?e(Array.from(t),n,r):`{${Object.keys(t).filter(e=>void 0!==t[e]).sort().map(r=>`${e(r,n)}:${e(t[r],n,r)}`).join(",")}}`}(e,t)};let{TreeCache:r1}=rq,r2={equality:"reference",eviction:"keep-all",maxSize:1/0},{isReactNative:r5,isWindow:r4}=tl,{isLoadable:r3,loadableWithError:r8,loadableWithPromise:r6,loadableWithValue:r9}=E,{WrappedValue:r7}=rW,{getNodeLoadable:oe,peekNodeLoadable:ot,setNodeValue:on}=eL,{saveDepsToStore:or}=eo,{DEFAULT_VALUE:oo,getConfigDeletionHandler:oi,getNode:oa,registerNode:ol}=q,{isRecoilValue:os}=B,{markRecoilValueModified:ou}=eX,{retainedByOptionWithDefault:oc}=e9,{recoilCallback:od}=rO,{startPerfBlock:of}={startPerfBlock:function(e){return()=>null}};class oh{}let op=new oh,ov=[],o_=new Map,oy=(r=0,()=>r++);function om(e){let t=null,{key:n,get:r,cachePolicy_UNSTABLE:o}=e,i=null!=e.set?e.set:void 0,a=new Set,l=function({equality:e=r2.equality,eviction:t=r2.eviction,maxSize:n=r2.maxSize}=r2,r){return function(e,t,n,r){switch(e){case"keep-all":return new r1({name:r,mapNodeValue:n});case"lru":return rQ({name:r,maxSize:h(t),mapNodeValue:n});case"most-recent":return rQ({name:r,maxSize:1,mapNodeValue:n})}throw d(`Unrecognized eviction policy ${e}`)}(t,n,function(e){switch(e){case"reference":return e=>e;case"value":return e=>r0(e)}throw d(`Unrecognized equality policy ${e}`)}(e),r)}(null!=o?o:{equality:"reference",eviction:"keep-all"},n),s=oc(e.retainedBy_UNSTABLE),u=new Map,c=0;function p(){return!N("recoil_memory_managament_2020")||c>0}function v(e){return e.getState().knownSelectors.add(n),c++,()=>{c--}}function _(){return void 0!==oi(n)&&!p()}function y(e,t){L(e,t)&&A(e),m(t,!0)}function m(e,n){let r=o_.get(e);if(null!=r){for(let e of r)ou(e,h(t));n&&o_.delete(e)}}function g(e,t){let n=o_.get(t);null==n&&o_.set(t,n=new Set),n.add(e)}function S(e,t,n,r,o,i){return t.then(r=>{if(!p())throw A(e),op;null!=i.loadingDepKey&&i.loadingDepPromise===t?n.atomValues.set(i.loadingDepKey,r9(r)):e.getState().knownSelectors.forEach(e=>{n.atomValues.delete(e)});let a=T(e,n);if(a&&"loading"!==a.state){if((L(e,o)||null==E(e))&&y(e,o),"hasValue"===a.state)return a.contents;throw a.contents}if(!L(e,o)){let t=R(e,n);if(null!=t)return t.loadingLoadable.contents}let[l,s]=w(e,n,o);if("loading"!==l.state&&(C(n,l,s),y(e,o)),"hasError"===l.state)throw l.contents;return l.contents}).catch(t=>{if(t instanceof oh)throw op;if(!p())throw A(e),op;throw C(n,r8(t),r),y(e,o),t})}function b(e,t,r,o){var i,l,s,u,c,d,f;for(let h of((L(e,o)||t.version===(null===(i=e.getState())||void 0===i?void 0:null===(l=i.currentTree)||void 0===l?void 0:l.version)||t.version===(null===(s=e.getState())||void 0===s?void 0:null===(u=s.nextTree)||void 0===u?void 0:u.version))&&or(n,r,e,null!==(c=null===(d=e.getState())||void 0===d?void 0:null===(f=d.nextTree)||void 0===f?void 0:f.version)&&void 0!==c?c:e.getState().currentTree.version),r))a.add(h)}function w(e,o,i){let a,l;let s=of(n),u=!0,c=!0,v=()=>{s(),c=!1},_=!1,g={loadingDepKey:null,loadingDepPromise:null},w=new Map;function T({key:t}){let n=oe(e,o,t);switch(w.set(t,n),!u&&(b(e,o,new Set(w.keys()),i),L(e,i)&&(h(E(e)).stateVersions.clear(),m(i,!1))),n.state){case"hasValue":return n.contents;case"hasError":throw n.contents;case"loading":throw g.loadingDepKey=t,g.loadingDepPromise=n.contents,n.contents}throw d("Invalid Loadable state")}try{(a=r({get:T,getCallback:n=>(...r)=>{if(c)throw d("Callbacks from getCallback() should only be called asynchronously after the selector is evalutated.  It can be used for selectors to return objects with callbacks that can work with Recoil state without a subscription.");return null!=t||rT(!1),od(e,n,r,{node:t})}}),a=os(a)?T(a):a,r3(a)&&("hasError"===a.state&&(_=!0),a=a.contents),f(a))?a=a.then(t=>{if(!p())throw A(e),op;let n=r9(t);return C(o,n,w),y(e,i),t}).catch(t=>{if(!p())throw A(e),op;if(f(t))return S(e,t,o,w,i,g);let n=r8(t);throw C(o,n,w),y(e,i),t}).finally(v):v(),a=a instanceof r7?a.value:a}catch(t){f(a=t)?a=S(e,a,o,w,i,g).finally(v):(_=!0,v())}return l=_?r8(a):f(a)?r6(a):r9(a),u=!1,function(e,t,n){if(L(e,t)){let t=E(e);null!=t&&(t.depValuesDiscoveredSoFarDuringAsyncWork=n)}}(e,i,w),b(e,o,new Set(w.keys()),i),[l,w]}function T(e,t){let r=t.atomValues.get(n);if(null!=r)return r;let o=new Set;try{r=l.get(n=>("string"!=typeof n&&rT(!1),oe(e,t,n).contents),{onNodeVisit:e=>{"branch"===e.type&&e.nodeKey!==n&&o.add(e.nodeKey)}})}catch(e){throw d(`Problem with cache lookup for selector "${n}": ${e.message}`)}if(r){var i;t.atomValues.set(n,r),b(e,t,o,null===(i=E(e))||void 0===i?void 0:i.executionID)}return r}function R(e,t){for(let n of ti([u.has(e)?[h(u.get(e))]:[],P(ey(u,([t])=>t!==e),([,e])=>e)])){if(n.stateVersions.get(t.version)||!function(n){for(let[r,o]of n)if(!oe(e,t,r).is(o))return!0;return!1}(n.depValuesDiscoveredSoFarDuringAsyncWork))return n.stateVersions.set(t.version,!0),n;n.stateVersions.set(t.version,!1)}}function E(e){return u.get(e)}function A(e){u.delete(e)}function L(e,t){var n;return t===(null===(n=E(e))||void 0===n?void 0:n.executionID)}function C(e,t,r){e.atomValues.set(n,t);try{l.set(Array.from(r.entries()).map(([e,t])=>[e,t.contents]),t)}catch(e){throw d(`Problem with setting cache for selector "${n}": ${e.message}`)}}function V(e,t){let r=t.atomValues.get(n);return null!=r?r:l.get(n=>{var r;return"string"!=typeof n&&rT(!1),null===(r=ot(e,t,n))||void 0===r?void 0:r.contents})}function M(e,t){return function(e){if(ov.includes(n))return r8(d(`Recoil selector has circular dependencies: ${ov.slice(ov.indexOf(n)).join(" → ")}`));ov.push(n);try{return e()}finally{ov.pop()}}(()=>(function(e,t){var n;let r=T(e,t);if(null!=r)return A(e),r;let o=R(e,t);if(null!=o)return(null===(n=o.loadingLoadable)||void 0===n?void 0:n.state)==="loading"&&g(e,o.executionID),o.loadingLoadable;let i=oy(),[a,l]=w(e,t,i);return"loading"===a.state?(u.set(e,{depValuesDiscoveredSoFarDuringAsyncWork:l,executionID:i,loadingLoadable:a,stateVersions:new Map([[t.version,!0]])}),g(e,i)):(A(e),C(t,a,l)),a})(e,t))}function D(e){e.atomValues.delete(n)}function I(e,n){for(let o of(null!=t||rT(!1),a)){var r;let t=oa(o);null===(r=t.clearCache)||void 0===r||r.call(t,e,n)}a.clear(),D(n),l.clear(),ou(e,t)}return t=null!=i?ol({key:n,nodeType:"selector",peek:V,get:M,set:(e,t,r)=>{let o=!1,a=new Map;function l({key:r}){if(o)throw d("Recoil: Async selector sets are not currently supported.");let i=oe(e,t,r);if("hasValue"===i.state)return i.contents;if("loading"===i.state){let e=`Getting value of asynchronous atom or selector "${r}" in a pending state while setting selector "${n}" is not yet supported.`;throw k(e),d(e)}throw i.contents}function s(n,r){if(o){let e="Recoil: Async selector sets are not currently supported.";throw k(e),d(e)}let i="function"==typeof r?r(l(n)):r;on(e,t,n.key,i).forEach((e,t)=>a.set(t,e))}let u=i({set:s,get:l,reset:function(e){s(e,oo)}},r);if(void 0!==u)throw f(u)?d("Recoil: Async selector sets are not currently supported."):d("Recoil: selector set should be a void function.");return o=!0,a},init:v,invalidate:D,clearCache:I,shouldDeleteConfigOnRelease:_,dangerouslyAllowMutability:e.dangerouslyAllowMutability,shouldRestoreFromSnapshots:!1,retainedBy:s}):ol({key:n,nodeType:"selector",peek:V,get:M,init:v,invalidate:D,clearCache:I,shouldDeleteConfigOnRelease:_,dangerouslyAllowMutability:e.dangerouslyAllowMutability,shouldRestoreFromSnapshots:!1,retainedBy:s})}om.value=e=>new r7(e);let{isLoadable:og,loadableWithError:oS,loadableWithPromise:ob,loadableWithValue:ow}=E,{WrappedValue:oT}=rW,{peekNodeInfo:oR}=eL,{DEFAULT_VALUE:oE,DefaultValue:oA,getConfigDeletionHandler:oN,registerNode:ok,setConfigDeletionHandler:oL}=q,{isRecoilValue:oC}=B,{getRecoilValueAsLoadable:oV,markRecoilValueModified:oM,setRecoilValue:oD,setRecoilValueLoadable:oI}=eX,{retainedByOptionWithDefault:oU}=e9,oO=e=>e instanceof oT?e.value:e;function oB(e){let{...t}=e,n="default"in e?e.default:new Promise(()=>{});return oC(n)?function(e){let t=oB({...e,default:oE,persistence_UNSTABLE:void 0===e.persistence_UNSTABLE?void 0:{...e.persistence_UNSTABLE,validator:t=>t instanceof oA?t:h(e.persistence_UNSTABLE).validator(t,oE)},effects:e.effects,effects_UNSTABLE:e.effects_UNSTABLE}),n=om({key:`${e.key}__withFallback`,get:({get:n})=>{let r=n(t);return r instanceof oA?e.default:r},set:({set:e},n)=>e(t,n),cachePolicy_UNSTABLE:{eviction:"most-recent"},dangerouslyAllowMutability:e.dangerouslyAllowMutability});return oL(n.key,oN(e.key)),n}({...t,default:n}):function(e){var t;let n;let{key:r,persistence_UNSTABLE:o}=e,i=oU(e.retainedBy_UNSTABLE),a=0;function l(e){return ob(e.then(e=>(s=ow(e),e)).catch(e=>{throw s=oS(e),e}))}let s=f(e.default)?l(e.default):og(e.default)?"loading"===e.default.state?l(e.default.contents):e.default:ow(oO(e.default));s.contents;let u=new Map;function c(e,t){var o,i;return null!==(o=null!==(i=t.atomValues.get(r))&&void 0!==i?i:n)&&void 0!==o?o:s}let p=ok({key:r,nodeType:"atom",peek:c,get:function(e,t){if(t.atomValues.has(r))return h(t.atomValues.get(r));if(!t.nonvalidatedAtoms.has(r))return s;{if(null!=n)return n;if(null==o)return x(`Tried to restore a persisted value for atom ${r} but it has no persistence settings.`),s;let e=t.nonvalidatedAtoms.get(r),i=o.validator(e,oE);return n=i instanceof oA?s:ow(i)}},set:function(e,t,o){if(t.atomValues.has(r)){let e=h(t.atomValues.get(r));if("hasValue"===e.state&&o===e.contents)return new Map}else if(!t.nonvalidatedAtoms.has(r)&&o instanceof oA)return new Map;return n=void 0,new Map().set(r,ow(o))},init:function(t,n,o){var i,l,h;a++,t.getState().knownAtoms.add(r),"loading"===s.state&&s.contents.finally(()=>{var e;(null!==(e=t.getState().nextTree)&&void 0!==e?e:t.getState().currentTree).atomValues.has(r)||oM(t,p)});let v=null!==(i=e.effects)&&void 0!==i?i:e.effects_UNSTABLE;if(null!=v){let e=oE,i=!0,a=!1,g=null;function _(o){if(i&&o.key===r){let r=e;return r instanceof oA?c(t,n):f(r)?ob(r.then(e=>e instanceof oA?s.toPromise():e)):ow(r)}return oV(t,o)}function y(e){return _(e).toPromise()}function m(n){var o;let a=oR(t,null!==(o=t.getState().nextTree)&&void 0!==o?o:t.getState().currentTree,n.key);return!i||n.key!==r||e instanceof oA?a:{...a,isSet:!0,loadable:_(n)}}let S=n=>r=>{if(i){let t=_(p),o="hasValue"===t.state?t.contents:oE;f(e="function"==typeof r?r(o):r)&&(e=e.then(e=>(g={effect:n,value:e},e)))}else{if(f(r))throw d("Setting atoms to async values is not implemented.");"function"!=typeof r&&(g={effect:n,value:oO(r)}),oD(t,p,"function"==typeof r?e=>{let t=oO(r(e));return g={effect:n,value:t},t}:oO(r))}},b=e=>()=>S(e)(oE),w=e=>n=>{var o;let{release:i}=t.subscribeToTransactions(t=>{var o,i,a,l,u;let{currentTree:c,previousTree:d}=t.getState();d||(k("Transaction subscribers notified without a next tree being present -- this is a bug in Recoil"),d=c);let f=null!==(o=c.atomValues.get(r))&&void 0!==o?o:s;if("hasValue"===f.state){let t=f.contents,o=null!==(i=d.atomValues.get(r))&&void 0!==i?i:s,h="hasValue"===o.state?o.contents:oE;(null===(a=g)||void 0===a?void 0:a.effect)!==e||(null===(l=g)||void 0===l?void 0:l.value)!==t?n(t,h,!c.atomValues.has(r)):(null===(u=g)||void 0===u?void 0:u.effect)===e&&(g=null)}},r);u.set(t,[...null!==(o=u.get(t))&&void 0!==o?o:[],i])};for(let n of v)try{let e=n({node:p,storeID:t.storeID,parentStoreID_UNSTABLE:t.parentStoreID,trigger:o,setSelf:S(n),resetSelf:b(n),onSet:w(n),getPromise:y,getLoadable:_,getInfo_UNSTABLE:m});null!=e&&u.set(t,[...null!==(l=u.get(t))&&void 0!==l?l:[],e])}catch(t){e=t,a=!0}if(i=!1,!(e instanceof oA)){let o=a?oS(e):f(e)?ob(function(e,t){let n=t.then(t=>{var o,i;return(null===(i=(null!==(o=e.getState().nextTree)&&void 0!==o?o:e.getState().currentTree).atomValues.get(r))||void 0===i?void 0:i.contents)===n&&oD(e,p,t),t}).catch(t=>{var o,i;throw(null===(i=(null!==(o=e.getState().nextTree)&&void 0!==o?o:e.getState().currentTree).atomValues.get(r))||void 0===i?void 0:i.contents)===n&&oI(e,p,oS(t)),t});return n}(t,e)):ow(oO(e));o.contents,n.atomValues.set(r,o),null===(h=t.getState().nextTree)||void 0===h||h.atomValues.set(r,o)}}return()=>{var e;a--,null===(e=u.get(t))||void 0===e||e.forEach(e=>e()),u.delete(t)}},invalidate:function(){n=void 0},shouldDeleteConfigOnRelease:function(){return void 0!==oN(r)&&a<=0},dangerouslyAllowMutability:e.dangerouslyAllowMutability,persistence_UNSTABLE:e.persistence_UNSTABLE?{type:e.persistence_UNSTABLE.type,backButton:e.persistence_UNSTABLE.backButton}:void 0,shouldRestoreFromSnapshots:!0,retainedBy:i});return p}({...t,default:n})}oB.value=e=>new oT(e);class ox{constructor(e){var t;p(this,"_map",void 0),p(this,"_keyMapper",void 0),this._map=new Map,this._keyMapper=null!==(t=null==e?void 0:e.mapKey)&&void 0!==t?t:e=>e}size(){return this._map.size}has(e){return this._map.has(this._keyMapper(e))}get(e){return this._map.get(this._keyMapper(e))}set(e,t){this._map.set(this._keyMapper(e),t)}delete(e){this._map.delete(this._keyMapper(e))}clear(){this._map.clear()}}var oP=Object.freeze({__proto__:null,MapCache:{MapCache:ox}.MapCache});let{LRUCache:oz}=rY,{MapCache:oF}=oP,o$={equality:"reference",eviction:"none",maxSize:1/0},{setConfigDeletionHandler:oG}=q,{setConfigDeletionHandler:oW}=q,oK=0;var oj=function(e){var t,n;let r=function({equality:e=o$.equality,eviction:t=o$.eviction,maxSize:n=o$.maxSize}=o$){return function(e,t,n){switch(e){case"keep-all":return new oF({mapKey:n});case"lru":return new oz({mapKey:n,maxSize:h(t)});case"most-recent":return new oz({mapKey:n,maxSize:1})}throw d(`Unrecognized eviction policy ${e}`)}(t,n,function(e){switch(e){case"reference":return e=>e;case"value":return e=>r0(e)}throw d(`Unrecognized equality policy ${e}`)}(e))}({equality:null!==(t=null===(n=e.cachePolicyForParams_UNSTABLE)||void 0===n?void 0:n.equality)&&void 0!==t?t:"value",eviction:"keep-all"});return t=>{var n;let o,i;try{o=r.get(t)}catch(t){throw d(`Problem with cache lookup for selector ${e.key}: ${t.message}`)}if(null!=o)return o;let a=`${e.key}__selectorFamily/${null!==(n=r0(t,{allowFunctions:!0}))&&void 0!==n?n:"void"}/${oK++}`,l=n=>e.get(t)(n),s=e.cachePolicy_UNSTABLE,u="function"==typeof e.retainedBy_UNSTABLE?e.retainedBy_UNSTABLE(t):e.retainedBy_UNSTABLE;if(null!=e.set){let n=e.set;i=om({key:a,get:l,set:(e,r)=>n(t)(e,r),cachePolicy_UNSTABLE:s,dangerouslyAllowMutability:e.dangerouslyAllowMutability,retainedBy_UNSTABLE:u})}else i=om({key:a,get:l,cachePolicy_UNSTABLE:s,dangerouslyAllowMutability:e.dangerouslyAllowMutability,retainedBy_UNSTABLE:u});return r.set(t,i),oW(i.key,()=>{r.delete(t)}),i}};oj({key:"__constant",get:e=>()=>e,cachePolicyForParams_UNSTABLE:{equality:"reference"}}),oj({key:"__error",get:e=>()=>{throw d(e)},cachePolicyForParams_UNSTABLE:{equality:"reference"}});let{loadableWithError:oH,loadableWithPromise:oq,loadableWithValue:oZ}=E;function oY(e,t){let n=Array(t.length).fill(void 0),r=Array(t.length).fill(void 0);for(let[o,i]of t.entries())try{n[o]=e(i)}catch(e){r[o]=e}return[n,r]}function oJ(e){return null!=e&&!f(e)}function oX(e){return Array.isArray(e)?e:Object.getOwnPropertyNames(e).map(t=>e[t])}function oQ(e,t){return Array.isArray(e)?t:Object.getOwnPropertyNames(e).reduce((e,n,r)=>({...e,[n]:t[r]}),{})}function o0(e,t,n){return oQ(e,n.map((e,n)=>null==e?oZ(t[n]):f(e)?oq(e):oH(e)))}let o1=oj({key:"__waitForNone",get:e=>({get:t})=>{let[n,r]=oY(t,oX(e));return o0(e,n,r)},dangerouslyAllowMutability:!0}),o2=oj({key:"__waitForAny",get:e=>({get:t})=>{let[n,r]=oY(t,oX(e));return r.some(e=>!f(e))?o0(e,n,r):new Promise(t=>{for(let[o,i]of r.entries())f(i)&&i.then(i=>{n[o]=i,r[o]=void 0,t(o0(e,n,r))}).catch(i=>{r[o]=i,t(o0(e,n,r))})})},dangerouslyAllowMutability:!0}),o5=oj({key:"__waitForAll",get:e=>({get:t})=>{let[n,r]=oY(t,oX(e));if(r.every(e=>null==e))return oQ(e,n);let o=r.find(oJ);if(null!=o)throw o;return Promise.all(r).then(t=>oQ(e,t.map((e,t)=>void 0===e?n[t]:e)))},dangerouslyAllowMutability:!0}),o4=oj({key:"__waitForAllSettled",get:e=>({get:t})=>{let[n,r]=oY(t,oX(e));return r.every(e=>!f(e))?o0(e,n,r):Promise.all(r.map((e,t)=>f(e)?e.then(e=>{n[t]=e,r[t]=void 0}).catch(e=>{n[t]=void 0,r[t]=e}):null)).then(()=>o0(e,n,r))},dangerouslyAllowMutability:!0}),o3=oj({key:"__noWait",get:e=>({get:t})=>{try{return om.value(oZ(t(e)))}catch(e){return om.value(f(e)?oq(e):oH(e))}},dangerouslyAllowMutability:!0}),{RecoilLoadable:o8}=E,{DefaultValue:o6}=q,{RecoilRoot:o9,useRecoilStoreID:o7}=no,{isRecoilValue:ie}=B,{retentionZone:it}=ev,{freshSnapshot:ir}=tV,{useRecoilState:io,useRecoilState_TRANSITION_SUPPORT_UNSTABLE:ii,useRecoilStateLoadable:ia,useRecoilValue:il,useRecoilValue_TRANSITION_SUPPORT_UNSTABLE:is,useRecoilValueLoadable:iu,useRecoilValueLoadable_TRANSITION_SUPPORT_UNSTABLE:ic,useResetRecoilState:id,useSetRecoilState:ih}={recoilComponentGetRecoilValueCount_FOR_TESTING:{current:0},useRecoilInterface:function(){let e=ny(),t=nE(),[,n]=nO([]),r=nU(new Set);r.current=new Set;let o=nU(new Set),i=nU(new Map),a=nM(e=>{let t=i.current.get(e);t&&(t.release(),i.current.delete(e))},[i]),l=nM((e,t)=>{i.current.has(t)&&n([])},[]);return nD(()=>{let n=t.current;et(r.current,o.current).forEach(t=>{if(i.current.has(t)){x(`Double subscription to RecoilValue "${t}"`);return}let r=nV(n,new nN(t),e=>l(e,t),e);i.current.set(t,r),n.getState().nextTree?n.getState().queuedComponentCallbacks_DEPRECATED.push(()=>{l(n.getState(),t)}):l(n.getState(),t)}),et(o.current,r.current).forEach(e=>{a(e)}),o.current=r.current}),nD(()=>{let n=i.current;return et(r.current,new Set(n.keys())).forEach(r=>{let o=nV(t.current,new nN(r),e=>l(e,r),e);n.set(r,o)}),()=>n.forEach((e,t)=>a(t))},[e,t,a,l]),nI(()=>{function e(e){return n=>{nL(t.current,e,n)}}function n(e){var n;r.current.has(e.key)||(r.current=nB(r.current,e.key));let o=t.current.getState();return nk(t.current,e,nb().early&&null!==(n=o.nextTree)&&void 0!==n?n:o.currentTree)}function o(e){return nP(n(e),e,t)}return{getRecoilValue:o,getRecoilValueLoadable:n,getRecoilState:function(t){return[o(t),e(t)]},getRecoilStateLoadable:function(t){return[n(t),e(t)]},getSetRecoilState:e,getResetRecoilState:function(e){return()=>nL(t.current,e,ng)}}},[r,t])},useRecoilState:function(e){return[nK(e),nj(e)]},useRecoilStateLoadable:function(e){return[nW(e),nj(e)]},useRecoilValue:nK,useRecoilValueLoadable:nW,useResetRecoilState:function(e){let t=nE();return nM(()=>{nL(t.current,e,ng)},[t,e])},useSetRecoilState:nj,useSetUnvalidatedAtomValues:function(){let e=nE();return(t,n={})=>{nm(()=>{e.current.addTransactionMetadata(n),t.forEach((t,n)=>nC(e.current,new nN(n),t))})}},useRecoilValueLoadable_TRANSITION_SUPPORT_UNSTABLE:nH,useRecoilValue_TRANSITION_SUPPORT_UNSTABLE:nq,useRecoilState_TRANSITION_SUPPORT_UNSTABLE:function(e){return[nq(e),nj(e)]}},{useGotoRecoilSnapshot:ip,useRecoilSnapshot:iv,useRecoilTransactionObserver:i_}=ri,{useRecoilCallback:iy}=rO,{noWait:im,waitForAll:ig,waitForAllSettled:iS,waitForAny:ib,waitForNone:iw}={waitForNone:o1,waitForAny:o2,waitForAll:o5,waitForAllSettled:o4,noWait:o3};var iT=o9,iR=oB,iE=il,iA=ih}}]);
//# sourceMappingURL=a20b2305.9850138361f09635.js.map